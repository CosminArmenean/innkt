{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/cosmi/source/repos/innkt/Frontend/innkt.Angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nexport let SecurityService = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class SecurityService {\n    constructor() {\n      this.securityConfig = {\n        enableTwoFactor: true,\n        requireStrongPassword: true,\n        sessionTimeout: 30,\n        maxLoginAttempts: 5,\n        enableAuditLog: true,\n        enableRateLimiting: true,\n        allowedOrigins: ['localhost', '127.0.0.1']\n      };\n      this.securityEventsSubject = new BehaviorSubject([]);\n      this.rolesSubject = new BehaviorSubject([]);\n      this.currentUserPermissionsSubject = new BehaviorSubject([]);\n      this.loginAttemptsSubject = new BehaviorSubject(new Map());\n      this.securityEvents$ = this.securityEventsSubject.asObservable();\n      this.roles$ = this.rolesSubject.asObservable();\n      this.currentUserPermissions$ = this.currentUserPermissionsSubject.asObservable();\n      this.initializeSecurity();\n    }\n    // Initialize security\n    initializeSecurity() {\n      this.loadDefaultRoles();\n      this.startSessionMonitoring();\n      this.startSecurityMonitoring();\n    }\n    // Load default roles\n    loadDefaultRoles() {\n      const defaultRoles = [{\n        name: 'admin',\n        permissions: [{\n          resource: '*',\n          action: '*'\n        }, {\n          resource: 'users',\n          action: 'manage'\n        }, {\n          resource: 'posts',\n          action: 'moderate'\n        }, {\n          resource: 'analytics',\n          action: 'view'\n        }],\n        description: 'Full system access'\n      }, {\n        name: 'moderator',\n        permissions: [{\n          resource: 'posts',\n          action: 'moderate'\n        }, {\n          resource: 'users',\n          action: 'view'\n        }, {\n          resource: 'reports',\n          action: 'handle'\n        }],\n        description: 'Content moderation access'\n      }, {\n        name: 'user',\n        permissions: [{\n          resource: 'posts',\n          action: 'create'\n        }, {\n          resource: 'posts',\n          action: 'read'\n        }, {\n          resource: 'profile',\n          action: 'manage'\n        }, {\n          resource: 'chat',\n          action: 'use'\n        }],\n        description: 'Standard user access'\n      }, {\n        name: 'guest',\n        permissions: [{\n          resource: 'posts',\n          action: 'read'\n        }, {\n          resource: 'search',\n          action: 'use'\n        }],\n        description: 'Limited read-only access'\n      }];\n      this.rolesSubject.next(defaultRoles);\n    }\n    // Start session monitoring\n    startSessionMonitoring() {\n      setInterval(() => {\n        this.checkSessionTimeout();\n      }, 60000); // Check every minute\n    }\n    // Start security monitoring\n    startSecurityMonitoring() {\n      // Monitor for suspicious activity\n      this.monitorSuspiciousActivity();\n      // Monitor for rate limiting violations\n      this.monitorRateLimiting();\n    }\n    // Check session timeout\n    checkSessionTimeout() {\n      const lastActivity = localStorage.getItem('lastActivity');\n      if (lastActivity) {\n        const lastActivityTime = new Date(lastActivity).getTime();\n        const currentTime = Date.now();\n        const timeoutMs = this.securityConfig.sessionTimeout * 60 * 1000;\n        if (currentTime - lastActivityTime > timeoutMs) {\n          this.handleSessionTimeout();\n        }\n      }\n    }\n    // Handle session timeout\n    handleSessionTimeout() {\n      this.logSecurityEvent({\n        type: 'logout',\n        ipAddress: this.getClientIP(),\n        userAgent: navigator.userAgent,\n        timestamp: new Date(),\n        details: 'Session timeout',\n        severity: 'medium'\n      });\n      // Clear user session\n      this.clearUserSession();\n      // Redirect to login\n      window.location.href = '/login?timeout=true';\n    }\n    // Monitor suspicious activity\n    monitorSuspiciousActivity() {\n      // Monitor for multiple failed login attempts\n      this.loginAttempts$.subscribe(attempts => {\n        attempts.forEach((count, userId) => {\n          if (count >= this.securityConfig.maxLoginAttempts) {\n            this.handleSuspiciousActivity(userId, 'Multiple failed login attempts');\n          }\n        });\n      });\n    }\n    // Monitor rate limiting\n    monitorRateLimiting() {\n      if (!this.securityConfig.enableRateLimiting) return;\n      // Implement rate limiting logic here\n      // This would typically track API calls per user/IP and block excessive requests\n    }\n    // Handle suspicious activity\n    handleSuspiciousActivity(userId, details) {\n      this.logSecurityEvent({\n        type: 'suspicious_activity',\n        userId,\n        ipAddress: this.getClientIP(),\n        userAgent: navigator.userAgent,\n        timestamp: new Date(),\n        details,\n        severity: 'high'\n      });\n      // Block user account temporarily\n      this.blockUserAccount(userId);\n    }\n    // Block user account\n    blockUserAccount(userId) {\n      // This would typically call the backend to block the account\n      console.warn(`User account ${userId} has been blocked due to suspicious activity`);\n    }\n    // Log security event\n    logSecurityEvent(event) {\n      if (!this.securityConfig.enableAuditLog) return;\n      const currentEvents = this.securityEventsSubject.value;\n      this.securityEventsSubject.next([...currentEvents, event]);\n      // Send to security backend\n      this.sendToSecurityBackend(event);\n      // Log to console in development\n      if (event.severity === 'critical' || event.severity === 'high') {\n        console.warn('Security Event:', event);\n      }\n    }\n    // Send to security backend\n    sendToSecurityBackend(event) {\n      return _asyncToGenerator(function* () {\n        try {\n          yield fetch('/api/security/events', {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(event)\n          });\n        } catch (error) {\n          console.warn('Failed to send security event:', error);\n        }\n      })();\n    }\n    // Check permission\n    hasPermission(resource, action, userId) {\n      const permissions = this.currentUserPermissionsSubject.value;\n      return permissions.some(permission => {\n        // Check wildcard permissions\n        if (permission.resource === '*' && permission.action === '*') {\n          return true;\n        }\n        if (permission.resource === '*' && permission.action === action) {\n          return true;\n        }\n        if (permission.resource === resource && permission.action === '*') {\n          return true;\n        }\n        // Check exact match\n        if (permission.resource === resource && permission.action === action) {\n          return true;\n        }\n        return false;\n      });\n    }\n    // Check role\n    hasRole(roleName) {\n      const roles = this.rolesSubject.value;\n      return roles.some(role => role.name === roleName);\n    }\n    // Assign role to user\n    assignRoleToUser(userId, roleName) {\n      const roles = this.rolesSubject.value;\n      const role = roles.find(r => r.name === roleName);\n      if (role) {\n        // This would typically call the backend to assign the role\n        console.log(`Role ${roleName} assigned to user ${userId}`);\n        // Update current user permissions if it's the current user\n        if (userId === this.getCurrentUserId()) {\n          this.currentUserPermissionsSubject.next(role.permissions);\n        }\n      }\n    }\n    // Validate password strength\n    validatePasswordStrength(password) {\n      if (!this.securityConfig.requireStrongPassword) {\n        return {\n          isValid: true,\n          score: 100,\n          feedback: []\n        };\n      }\n      const feedback = [];\n      let score = 0;\n      // Length check\n      if (password.length >= 8) {\n        score += 20;\n      } else {\n        feedback.push('Password must be at least 8 characters long');\n      }\n      // Uppercase check\n      if (/[A-Z]/.test(password)) {\n        score += 20;\n      } else {\n        feedback.push('Password must contain at least one uppercase letter');\n      }\n      // Lowercase check\n      if (/[a-z]/.test(password)) {\n        score += 20;\n      } else {\n        feedback.push('Password must contain at least one lowercase letter');\n      }\n      // Number check\n      if (/\\d/.test(password)) {\n        score += 20;\n      } else {\n        feedback.push('Password must contain at least one number');\n      }\n      // Special character check\n      if (/[!@#$%^&*(),.?\":{}|<>]/.test(password)) {\n        score += 20;\n      } else {\n        feedback.push('Password must contain at least one special character');\n      }\n      const isValid = score >= 80;\n      return {\n        isValid,\n        score,\n        feedback\n      };\n    }\n    // Track login attempt\n    trackLoginAttempt(userId, success) {\n      const currentAttempts = this.loginAttemptsSubject.value;\n      if (success) {\n        // Reset attempts on successful login\n        currentAttempts.delete(userId);\n        this.logSecurityEvent({\n          type: 'login',\n          userId,\n          ipAddress: this.getClientIP(),\n          userAgent: navigator.userAgent,\n          timestamp: new Date(),\n          details: 'Successful login',\n          severity: 'low'\n        });\n      } else {\n        // Increment failed attempts\n        const currentCount = currentAttempts.get(userId) || 0;\n        currentAttempts.set(userId, currentCount + 1);\n        this.logSecurityEvent({\n          type: 'failed_login',\n          userId,\n          ipAddress: this.getClientIP(),\n          userAgent: navigator.userAgent,\n          timestamp: new Date(),\n          details: `Failed login attempt ${currentCount + 1}`,\n          severity: currentCount + 1 >= this.securityConfig.maxLoginAttempts ? 'high' : 'medium'\n        });\n      }\n      this.loginAttemptsSubject.next(new Map(currentAttempts));\n    }\n    // Get client IP address\n    getClientIP() {\n      // This is a simplified version - in production, you'd get this from the server\n      return '127.0.0.1';\n    }\n    // Get current user ID\n    getCurrentUserId() {\n      // This would typically come from your auth service\n      return localStorage.getItem('userId') || undefined;\n    }\n    // Clear user session\n    clearUserSession() {\n      localStorage.removeItem('userId');\n      localStorage.removeItem('lastActivity');\n      localStorage.removeItem('accessToken');\n      this.currentUserPermissionsSubject.next([]);\n    }\n    // Update last activity\n    updateLastActivity() {\n      localStorage.setItem('lastActivity', new Date().toISOString());\n    }\n    // Get security configuration\n    getSecurityConfig() {\n      return {\n        ...this.securityConfig\n      };\n    }\n    // Update security configuration\n    updateSecurityConfig(config) {\n      this.securityConfig = {\n        ...this.securityConfig,\n        ...config\n      };\n    }\n    // Get security events\n    getSecurityEvents() {\n      return this.securityEvents$;\n    }\n    // Get security events by severity\n    getSecurityEventsBySeverity(severity) {\n      return this.securityEvents$.pipe(map(events => events.filter(event => event.severity === severity)));\n    }\n    // Get login attempts\n    get loginAttempts$() {\n      return this.loginAttemptsSubject.asObservable();\n    }\n    // Check if user is blocked\n    isUserBlocked(userId) {\n      const attempts = this.loginAttemptsSubject.value;\n      const failedAttempts = attempts.get(userId) || 0;\n      return failedAttempts >= this.securityConfig.maxLoginAttempts;\n    }\n    // Unblock user\n    unblockUser(userId) {\n      const currentAttempts = this.loginAttemptsSubject.value;\n      currentAttempts.delete(userId);\n      this.loginAttemptsSubject.next(new Map(currentAttempts));\n      console.log(`User ${userId} has been unblocked`);\n    }\n    // Validate origin\n    validateOrigin(origin) {\n      return this.securityConfig.allowedOrigins.some(allowed => origin.includes(allowed));\n    }\n    // Sanitize input\n    sanitizeInput(input) {\n      // Basic XSS prevention\n      return input.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\\//g, '&#x2F;');\n    }\n    // Generate secure token\n    generateSecureToken() {\n      const array = new Uint8Array(32);\n      crypto.getRandomValues(array);\n      return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n    }\n    // Hash password (client-side hashing for additional security)\n    hashPassword(password) {\n      return _asyncToGenerator(function* () {\n        const encoder = new TextEncoder();\n        const data = encoder.encode(password);\n        const hash = yield crypto.subtle.digest('SHA-256', data);\n        return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');\n      })();\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function SecurityService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SecurityService)();\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: SecurityService,\n      factory: SecurityService.ɵfac,\n      providedIn: 'root'\n    }));\n  }\n  _staticBlock();\n  return SecurityService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}