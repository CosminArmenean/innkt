{"ast":null,"code":"import { BehaviorSubject, interval } from 'rxjs';\nimport { map, catchError } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let ThreatDetectionService = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class ThreatDetectionService {\n    constructor(http) {\n      this.http = http;\n      this.baseUrl = environment.apiUrl + '/api/ThreatDetection';\n      this.activeThreatsSubject = new BehaviorSubject([]);\n      this.incidentsSubject = new BehaviorSubject([]);\n      this.metricsSubject = new BehaviorSubject(null);\n      this.patternsSubject = new BehaviorSubject([]);\n      this.isMonitoringSubject = new BehaviorSubject(false);\n      this.activeThreats$ = this.activeThreatsSubject.asObservable();\n      this.incidents$ = this.incidentsSubject.asObservable();\n      this.metrics$ = this.metricsSubject.asObservable();\n      this.patterns$ = this.patternsSubject.asObservable();\n      this.isMonitoring$ = this.isMonitoringSubject.asObservable();\n      this.initializeService();\n    }\n    initializeService() {\n      // Load initial data\n      this.loadThreatMetrics();\n      this.loadActiveIncidents();\n      this.loadThreatPatterns();\n    }\n    // Start real-time threat monitoring\n    startMonitoring(intervalMs = 30000) {\n      if (this.monitoringInterval) {\n        clearInterval(this.monitoringInterval);\n      }\n      this.isMonitoringSubject.next(true);\n      this.monitoringInterval = interval(intervalMs).subscribe(() => {\n        this.refreshThreatData();\n      });\n    }\n    // Stop real-time monitoring\n    stopMonitoring() {\n      if (this.monitoringInterval) {\n        clearInterval(this.monitoringInterval);\n        this.monitoringInterval = undefined;\n      }\n      this.isMonitoringSubject.next(false);\n    }\n    // Analyze a request for threats\n    analyzeRequest(request) {\n      return this.http.post(`${this.baseUrl}/analyze`, request).pipe(map(result => ({\n        ...result,\n        analyzedAt: new Date(result.analyzedAt)\n      })), catchError(error => {\n        console.error('Error analyzing threat:', error);\n        throw error;\n      }));\n    }\n    // Detect anomalies\n    detectAnomalies(userId, ipAddress, endpoint, from, to) {\n      const request = {\n        userId,\n        ipAddress,\n        endpoint,\n        from: from.toISOString(),\n        to: to.toISOString(),\n        type: 1 // Behavioral\n      };\n      return this.http.post(`${this.baseUrl}/anomaly/detect`, request);\n    }\n    // Execute automated response\n    executeAutomatedResponse(incidentId, threatLevel, actions) {\n      const request = {\n        incidentId,\n        threatLevel: this.mapThreatLevel(threatLevel),\n        actions,\n        requireConfirmation: false,\n        parameters: {\n          block_duration: 15,\n          notification_level: 'high'\n        }\n      };\n      return this.http.post(`${this.baseUrl}/response/execute`, request);\n    }\n    // Load threat metrics\n    loadThreatMetrics() {\n      const from = new Date();\n      from.setDate(from.getDate() - 7);\n      const to = new Date();\n      this.http.get(`${this.baseUrl}/metrics`, {\n        params: {\n          from: from.toISOString(),\n          to: to.toISOString()\n        }\n      }).subscribe({\n        next: metrics => {\n          this.metricsSubject.next({\n            ...metrics,\n            generatedAt: new Date(metrics.generatedAt),\n            trends: metrics.trends.map(trend => ({\n              ...trend,\n              date: new Date(trend.date)\n            }))\n          });\n        },\n        error: error => {\n          console.error('Error loading threat metrics:', error);\n        }\n      });\n    }\n    // Load active incidents\n    loadActiveIncidents() {\n      this.http.get(`${this.baseUrl}/incidents/active`).subscribe({\n        next: incidents => {\n          this.incidentsSubject.next(incidents.map(incident => ({\n            ...incident,\n            createdAt: new Date(incident.createdAt),\n            resolvedAt: incident.resolvedAt ? new Date(incident.resolvedAt) : undefined\n          })));\n        },\n        error: error => {\n          console.error('Error loading active incidents:', error);\n        }\n      });\n    }\n    // Load threat patterns\n    loadThreatPatterns() {\n      this.http.get(`${this.baseUrl}/patterns`).subscribe({\n        next: patterns => {\n          this.patternsSubject.next(patterns.map(pattern => ({\n            ...pattern,\n            createdAt: new Date(pattern.createdAt),\n            lastUpdated: pattern.lastUpdated ? new Date(pattern.lastUpdated) : undefined\n          })));\n        },\n        error: error => {\n          console.error('Error loading threat patterns:', error);\n        }\n      });\n    }\n    // Create new incident\n    createIncident(title, description, severity, assignedTo, tags) {\n      const request = {\n        title,\n        description,\n        severity: this.mapThreatLevel(severity),\n        assignedTo,\n        tags,\n        metadata: {}\n      };\n      return this.http.post(`${this.baseUrl}/incidents`, request).pipe(map(incident => ({\n        ...incident,\n        createdAt: new Date(incident.createdAt),\n        resolvedAt: incident.resolvedAt ? new Date(incident.resolvedAt) : undefined\n      })));\n    }\n    // Update incident status\n    updateIncidentStatus(incidentId, status) {\n      return this.http.put(`${this.baseUrl}/incidents/${incidentId}/status`, {\n        status\n      });\n    }\n    // Refresh all threat data\n    refreshThreatData() {\n      this.loadThreatMetrics();\n      this.loadActiveIncidents();\n    }\n    // Map threat level string to enum\n    mapThreatLevel(level) {\n      switch (level.toLowerCase()) {\n        case 'low':\n          return 1;\n        case 'medium':\n          return 2;\n        case 'high':\n          return 3;\n        case 'critical':\n          return 4;\n        default:\n          return 1;\n      }\n    }\n    // Get threat level color for UI\n    getThreatLevelColor(level) {\n      switch (level.toLowerCase()) {\n        case 'low':\n          return '#28a745';\n        case 'medium':\n          return '#ffc107';\n        case 'high':\n          return '#fd7e14';\n        case 'critical':\n          return '#dc3545';\n        default:\n          return '#6c757d';\n      }\n    }\n    // Get threat level icon for UI\n    getThreatLevelIcon(level) {\n      switch (level.toLowerCase()) {\n        case 'low':\n          return 'shield-check';\n        case 'medium':\n          return 'shield-exclamation';\n        case 'high':\n          return 'shield-x';\n        case 'critical':\n          return 'exclamation-triangle';\n        default:\n          return 'shield';\n      }\n    }\n    // Cleanup on destroy\n    ngOnDestroy() {\n      this.stopMonitoring();\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function ThreatDetectionService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ThreatDetectionService)(i0.ɵɵinject(i1.HttpClient));\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: ThreatDetectionService,\n      factory: ThreatDetectionService.ɵfac,\n      providedIn: 'root'\n    }));\n  }\n  _staticBlock();\n  return ThreatDetectionService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}