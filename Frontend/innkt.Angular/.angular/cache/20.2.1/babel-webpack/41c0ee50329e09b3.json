{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/cosmi/source/repos/innkt/Frontend/innkt.Angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject, interval } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport let PerformanceService = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class PerformanceService {\n    constructor(ngZone) {\n      this.ngZone = ngZone;\n      this.metricsSubject = new BehaviorSubject({\n        memoryUsage: 0,\n        cpuUsage: 0,\n        responseTime: 0,\n        pageLoadTime: 0,\n        networkLatency: 0,\n        errorRate: 0,\n        userInteractions: 0,\n        timestamp: new Date()\n      });\n      this.thresholds = {\n        memoryWarning: 100,\n        // 100 MB\n        memoryCritical: 200,\n        // 200 MB\n        responseTimeWarning: 1000,\n        // 1 second\n        responseTimeCritical: 3000,\n        // 3 seconds\n        errorRateWarning: 5,\n        // 5%\n        errorRateCritical: 10 // 10%\n      };\n      this.performanceObserver = null;\n      this.memoryObserver = null;\n      this.errorCount = 0;\n      this.totalRequests = 0;\n      this.userInteractionCount = 0;\n      this.pageLoadStartTime = performance.now();\n      this.metrics$ = this.metricsSubject.asObservable();\n      this.initializePerformanceMonitoring();\n    }\n    // Initialize performance monitoring\n    initializePerformanceMonitoring() {\n      // Monitor memory usage\n      this.startMemoryMonitoring();\n      // Monitor page performance\n      this.startPagePerformanceMonitoring();\n      // Monitor user interactions\n      this.startUserInteractionMonitoring();\n      // Monitor network performance\n      this.startNetworkMonitoring();\n      // Start periodic metrics collection\n      this.startPeriodicMonitoring();\n    }\n    // Memory monitoring\n    startMemoryMonitoring() {\n      if ('memory' in performance) {\n        const memory = performance.memory;\n        if (memory) {\n          interval(5000) // Check every 5 seconds\n          .subscribe(() => {\n            const memoryUsageMB = Math.round(memory.usedJSHeapSize / 1024 / 1024);\n            this.updateMetrics({\n              memoryUsage: memoryUsageMB\n            });\n            // Check thresholds\n            this.checkMemoryThresholds(memoryUsageMB);\n          });\n        }\n      }\n    }\n    // Page performance monitoring\n    startPagePerformanceMonitoring() {\n      // Monitor page load time\n      window.addEventListener('load', () => {\n        const loadTime = performance.now() - this.pageLoadStartTime;\n        this.updateMetrics({\n          pageLoadTime: loadTime\n        });\n      });\n      // Monitor navigation timing\n      if ('navigation' in performance) {\n        const navigation = performance.navigation;\n        if (navigation) {\n          const responseTime = navigation.responseEnd - navigation.requestStart;\n          this.updateMetrics({\n            responseTime\n          });\n        }\n      }\n      // Monitor resource timing\n      if ('PerformanceObserver' in window) {\n        try {\n          this.performanceObserver = new PerformanceObserver(list => {\n            list.getEntries().forEach(entry => {\n              if (entry.entryType === 'resource') {\n                const resourceEntry = entry;\n                this.updateMetrics({\n                  networkLatency: resourceEntry.responseStart - resourceEntry.requestStart\n                });\n              }\n            });\n          });\n          this.performanceObserver.observe({\n            entryTypes: ['resource']\n          });\n        } catch (error) {\n          console.warn('PerformanceObserver not supported:', error);\n        }\n      }\n    }\n    // User interaction monitoring\n    startUserInteractionMonitoring() {\n      const interactionEvents = ['click', 'keydown', 'scroll', 'mousemove'];\n      interactionEvents.forEach(eventType => {\n        document.addEventListener(eventType, () => {\n          this.userInteractionCount++;\n          this.updateMetrics({\n            userInteractions: this.userInteractionCount\n          });\n        }, {\n          passive: true\n        });\n      });\n    }\n    // Network performance monitoring\n    startNetworkMonitoring() {\n      var _this = this;\n      // Monitor fetch requests\n      const originalFetch = window.fetch;\n      window.fetch = /*#__PURE__*/_asyncToGenerator(function* (...args) {\n        const startTime = performance.now();\n        _this.totalRequests++;\n        try {\n          const response = yield originalFetch(...args);\n          const endTime = performance.now();\n          const responseTime = endTime - startTime;\n          _this.updateMetrics({\n            responseTime\n          });\n          return response;\n        } catch (error) {\n          _this.errorCount++;\n          _this.updateErrorRate();\n          throw error;\n        }\n      });\n      // Monitor XMLHttpRequest (simplified for now)\n      console.log('XMLHttpRequest monitoring initialized');\n    }\n    // Periodic monitoring\n    startPeriodicMonitoring() {\n      interval(10000) // Update every 10 seconds\n      .subscribe(() => {\n        this.collectMetrics();\n      });\n    }\n    // Collect all metrics\n    collectMetrics() {\n      const currentMetrics = this.metricsSubject.value;\n      // Update error rate\n      this.updateErrorRate();\n      // Update timestamp\n      currentMetrics.timestamp = new Date();\n      this.metricsSubject.next({\n        ...currentMetrics\n      });\n    }\n    // Update specific metrics\n    updateMetrics(updates) {\n      const currentMetrics = this.metricsSubject.value;\n      this.metricsSubject.next({\n        ...currentMetrics,\n        ...updates\n      });\n    }\n    // Update error rate\n    updateErrorRate() {\n      if (this.totalRequests > 0) {\n        const errorRate = this.errorCount / this.totalRequests * 100;\n        this.updateMetrics({\n          errorRate\n        });\n      }\n    }\n    // Check memory thresholds\n    checkMemoryThresholds(memoryUsage) {\n      if (memoryUsage >= this.thresholds.memoryCritical) {\n        this.emitPerformanceWarning('CRITICAL', `Memory usage is critical: ${memoryUsage}MB`);\n      } else if (memoryUsage >= this.thresholds.memoryWarning) {\n        this.emitPerformanceWarning('WARNING', `Memory usage is high: ${memoryUsage}MB`);\n      }\n    }\n    // Check response time thresholds\n    checkResponseTimeThresholds(responseTime) {\n      if (responseTime >= this.thresholds.responseTimeCritical) {\n        this.emitPerformanceWarning('CRITICAL', `Response time is critical: ${responseTime}ms`);\n      } else if (responseTime >= this.thresholds.responseTimeWarning) {\n        this.emitPerformanceWarning('WARNING', `Response time is slow: ${responseTime}ms`);\n      }\n    }\n    // Check error rate thresholds\n    checkErrorRateThresholds(errorRate) {\n      if (errorRate >= this.thresholds.errorRateCritical) {\n        this.emitPerformanceWarning('CRITICAL', `Error rate is critical: ${errorRate.toFixed(2)}%`);\n      } else if (errorRate >= this.thresholds.errorRateWarning) {\n        this.emitPerformanceWarning('WARNING', `Error rate is high: ${errorRate.toFixed(2)}%`);\n      }\n    }\n    // Emit performance warnings\n    emitPerformanceWarning(level, message) {\n      const warning = {\n        level,\n        message,\n        timestamp: new Date(),\n        metrics: this.metricsSubject.value\n      };\n      // Emit warning event\n      this.ngZone.run(() => {\n        console.warn(`Performance ${level}:`, warning);\n        // You could emit this to a warning service or notification system\n      });\n    }\n    // Public methods for external use\n    getCurrentMetrics() {\n      return this.metricsSubject.value;\n    }\n    getMetricsHistory() {\n      return this.metricsSubject.asObservable();\n    }\n    // Track custom performance metric\n    trackCustomMetric(name, value) {\n      const currentMetrics = this.metricsSubject.value;\n      currentMetrics[name] = value;\n      this.metricsSubject.next({\n        ...currentMetrics\n      });\n    }\n    // Track API call performance\n    trackApiCall(url, method, startTime, endTime, success) {\n      const duration = endTime - startTime;\n      this.totalRequests++;\n      if (!success) {\n        this.errorCount++;\n        this.updateErrorRate();\n      }\n      this.updateMetrics({\n        responseTime: duration\n      });\n      // Log API performance\n      console.log(`API Call: ${method} ${url} - ${duration.toFixed(2)}ms - ${success ? 'SUCCESS' : 'FAILED'}`);\n    }\n    // Get performance report\n    getPerformanceReport() {\n      const metrics = this.getCurrentMetrics();\n      const recommendations = [];\n      let health = 'GOOD';\n      // Memory recommendations\n      if (metrics.memoryUsage >= this.thresholds.memoryCritical) {\n        health = 'CRITICAL';\n        recommendations.push('Memory usage is critical. Consider optimizing memory usage or increasing available memory.');\n      } else if (metrics.memoryUsage >= this.thresholds.memoryWarning) {\n        health = 'WARNING';\n        recommendations.push('Memory usage is high. Monitor for memory leaks.');\n      }\n      // Response time recommendations\n      if (metrics.responseTime >= this.thresholds.responseTimeCritical) {\n        health = 'CRITICAL';\n        recommendations.push('Response time is critical. Investigate performance bottlenecks.');\n      } else if (metrics.responseTime >= this.thresholds.responseTimeWarning) {\n        health = 'WARNING';\n        recommendations.push('Response time is slow. Consider optimization.');\n      }\n      // Error rate recommendations\n      if (metrics.errorRate >= this.thresholds.errorRateCritical) {\n        health = 'CRITICAL';\n        recommendations.push('Error rate is critical. Investigate system stability.');\n      } else if (metrics.errorRate >= this.thresholds.errorRateWarning) {\n        health = 'WARNING';\n        recommendations.push('Error rate is high. Review error handling.');\n      }\n      return {\n        summary: metrics,\n        recommendations,\n        health\n      };\n    }\n    // Update thresholds\n    updateThresholds(newThresholds) {\n      this.thresholds = {\n        ...this.thresholds,\n        ...newThresholds\n      };\n    }\n    // Reset metrics\n    resetMetrics() {\n      this.errorCount = 0;\n      this.totalRequests = 0;\n      this.userInteractionCount = 0;\n      this.pageLoadStartTime = performance.now();\n      this.metricsSubject.next({\n        memoryUsage: 0,\n        cpuUsage: 0,\n        responseTime: 0,\n        pageLoadTime: 0,\n        networkLatency: 0,\n        errorRate: 0,\n        userInteractions: 0,\n        timestamp: new Date()\n      });\n    }\n    // Cleanup\n    destroy() {\n      if (this.performanceObserver) {\n        this.performanceObserver.disconnect();\n      }\n      if (this.memoryObserver) {\n        this.memoryObserver.disconnect();\n      }\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function PerformanceService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || PerformanceService)(i0.ɵɵinject(i0.NgZone));\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: PerformanceService,\n      factory: PerformanceService.ɵfac,\n      providedIn: 'root'\n    }));\n  }\n  _staticBlock();\n  return PerformanceService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}